[{"categories":["生活"],"content":" 功能测试文章 ","date":"2023-11-28","objectID":"/5/:0:0","tags":["拍照"],"title":"杂拍","uri":"/5/"},{"categories":["技术"],"content":"远程 Debug 配置 IDEA中添加Remote JVM Debug配置项，拷贝以下配置 -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 ","date":"2023-11-21","objectID":"/1/:1:0","tags":["IDEA","Docker"],"title":"IDEA远程调试docker容器","uri":"/1/"},{"categories":["技术"],"content":"容器启动配置 ","date":"2023-11-21","objectID":"/1/:2:0","tags":["IDEA","Docker"],"title":"IDEA远程调试docker容器","uri":"/1/"},{"categories":["技术"],"content":"dockerfile配置 FROM openjdk:8 ADD ./myapp.jar ./ EXPOSE 8082 EXPOSE 5005 ENTRYPOINT [\"java\",\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005\",\"-jar\",\"myapp.jar\",\"--spring.profiles.active=prod\"] ","date":"2023-11-21","objectID":"/1/:2:1","tags":["IDEA","Docker"],"title":"IDEA远程调试docker容器","uri":"/1/"},{"categories":["技术"],"content":"docker-compose配置 暴露debug端口 Server: image: server container_name: server ports: - \"30010:8082\" - \"5005:5005\" ","date":"2023-11-21","objectID":"/1/:2:2","tags":["IDEA","Docker"],"title":"IDEA远程调试docker容器","uri":"/1/"},{"categories":["技术"],"content":"配置debug调试 ","date":"2023-11-21","objectID":"/1/:2:3","tags":["IDEA","Docker"],"title":"IDEA远程调试docker容器","uri":"/1/"},{"categories":["技术"],"content":" 平常函数式组件用的多一点,React Hooks 是 React 团队在两年前的 16.8 版本推出的一套全新的机制,它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 ","date":"2023-11-21","objectID":"/3/:0:0","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"几个内置Hooks的作用以及使用 ","date":"2023-11-21","objectID":"/3/:1:0","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"useState ：让函数组件具有维持状态的能力 const[count, setCount]=useState(0); 优点： 让函数组件具有维持状态的能力，即：在一个函数组件的多次渲染之间，这个 state 是共享的。便于维护状态。 ","date":"2023-11-21","objectID":"/3/:1:1","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"缺点： 一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂。 用法： useState(initialState) 的参数 initialState 是创建 state 的初始值。 它可以是任意类型，比如数字、对象、数组等等。 useState() 的返回值是一个有着两个元素的数组。第一个数组元素用来读取 state 的值，第二个则是用来设置这个 state 的值。 在这里要注意的是，state 的变量（例子中的 count）是只读的，所以我们必须通过第二个数组元素 setCount 来设置它的值。 如果要创建多个 state ，那么我们就需要多次调用 useState。 什么样的值应该保存在 state 中？ 通常来说，我们要遵循的一个原则就是：state 中不要保存可以通过计算得到的值 。 从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。 从 URL 中读到的值。比如有时需要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候从 URL 中读取，而不是读出来直接放到 state 里。 从 cookie、localStorage 中读取的值。通常来说，也是每次要用的时候直接去读取，而不是读出来后放到 state 里。 useEffect：执行副作用 useEffect(fn, deps); useEffect ，顾名思义，用于执行一段副作用。 ","date":"2023-11-21","objectID":"/3/:1:2","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"什么是副作用？ 通常来说，副作用是指一段和当前执行结果无关的代码。比如说要修改函数外部的某个变量，要发起一个请求，等等。 也就是说，在函数组件的当次执行过程中， useEffect 中代码的执行是不影响渲染出来的 UI 的。 对应到 Class 组件，那么 useEffect 就涵盖了 ComponentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期方法。不过如果你习惯了使用 Class 组件，那千万不要按照把 useEffect 对应到某个或者某几个生命周期的方法。你只要记住，useEffect 是每次组件 render 完后判断依赖并执行就可以了。 useEffect 还有两个特殊的用法：没有依赖项，以及依赖项作为空数组。我们来具体分析下。 没有依赖项，则每次 render 后都会重新执行。例如： javascript 复制代码useEffect(() =\u003e { // 每次 render 完一定执行 console.log('渲染...........'); }); 空数组作为依赖项，则只在首次执行时触发，对应到 Class 组件就是 componentDidMount。例如： scss 复制代码useEffect(() =\u003e { // 组件首次渲染时执行，等价于 class 组件中的 componentDidMount console.log('did mount........'); }, []); ","date":"2023-11-21","objectID":"/3/:1:3","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"小结用法: 总结一下，useEffect 让我们能够在下面四种时机去执行一个回调函数产生副作用： 每次 render 后执行：不提供第二个依赖项参数。 比如useEffect(() =\u003e {})。 仅第一次 render 后执行：提供一个空数组作为依赖项。 比如useEffect(() =\u003e {}, [])。 第一次以及依赖项发生变化后执行：提供依赖项数组。 比如useEffect(() =\u003e {}, [deps])。 组件 unmount 后执行：返回一个回调函数。 比如useEffect() =\u003e { return () =\u003e {} }, [])。 useCallback：缓存回调函数 useCallback(fn, deps) ","date":"2023-11-21","objectID":"/3/:1:4","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"为什么要使用useCallback? 在 React 函数组件中， 每一次 UI 的变化，都是通过重新执行整个函数来完成的 ，这和传统的 Class 组件有很大区别：函数组件中并没有一个直接的方式在多次渲染之间维持一个状态。 javascript 复制代码function Counter() { const [count, setCount] = useState(0); const handleIncrement = () =\u003e setCount(count+1); return \u003cbutton onClick={handleIncrement}\u003e+\u003c/button\u003e } 思考下这个过程。 每次组件状态发生变化的时候，函数组件实际上都会重新执行一遍 。在每次执行的时候，实际上都会创建一个新的事件处理函数 handleIncrement 。 这也意味着，即使 count 没有发生变化，但是函数组件因为其它状态发生变化而重新渲染时（函数组件重新被执行），这种写法也会每次创建一个新的函数。创建一个新的事件处理函数，虽然不影响结果的正确性，但其实是没必要的。因为这样做不仅增加了系统的开销，更重要的是： 每次创建新函数的方式会让接收事件处理函数的组件，需要重新渲染 。 比如这个例子中的 button 组件，接收了 handleIncrement ，并作为一个属性。如果每次都是一个新的，那么这个 React 就会认为这个组件的 props 发生了变化，从而必须重新渲染。因此，我们需要做到的是： 只有当 count 发生变化时，我们才需要重新定一个回调函数 。而这正是 useCallback 这个 Hook 的作用。 javascript 复制代码import React, { useState, useCallback } from 'react'; function Counter() { const [count, setCount] = useState(0); const handleIncrement = useCallback( () =\u003e setCount(count + 1), [count], // 只有当 count 发生变化时，才会重新创建回调函数 ); return \u003cbutton onClick={handleIncrement}\u003e+\u003c/button\u003e } useMemo：缓存计算的结果 js 复制代码useMemo(fn, deps); useCallback(fn, deps) 相当于 useMemo(() =\u003e fn, deps)。 这里的 fn 是产生所需数据的一个 计算函数 。通常来说， fn 会使用 deps 中声明的一些变量来生成一个结果，用来渲染出最终的 UI 。 这个场景应该很容易理解：如果某个 数据 是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算。 ","date":"2023-11-21","objectID":"/3/:1:5","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"避免重复计算 通过 useMemo 这个 Hook，可以避免在用到的数据没发生变化时进行的重复计算。虽然例子展示的是一个很简单的场景，但如果是一个复杂的计算，那么对于 提升性能 会有很大的帮助。 举个例子： css 复制代码const calc = (a, b) =\u003e { // 假设这里做了复杂的计算，暂时用次幂模拟 return a ** b; } const MyComponent = (props) =\u003e { const {a, b} = props; const c = calc(a, b); return \u003cdiv\u003ec: {c}\u003c/div\u003e; } 如果 calc 计算耗时 1000ms，那么每次渲染都要等待这么久，怎么优化呢？ a, b 值不变的情况下，得出的 c 定是相同的。 所以我们可以用 useMemo 把值给缓存起来，避免重复计算相同的结果。 javascript 复制代码const calc = (a, b) =\u003e { // 假设这里做了复杂的计算，暂时用次幂模拟 return a ** b; } const MyComponent = (props) =\u003e { const {a, b} = props; // 缓存 const c = React.useMemo(() =\u003e calc(a, b), [a, b]); return \u003cdiv\u003ec: {c}\u003c/div\u003e; } useCallback 的功能其实是可以用 useMemo 来实现的: javascript 复制代码 const myEventHandler = useMemo(() =\u003e { // 返回一个函数作为缓存结果 return () =\u003e { // 在这里进行事件处理 } }, [dep1, dep2]); ","date":"2023-11-21","objectID":"/3/:1:6","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"小结一下： 感觉到这有这种感觉，其实 hook 就是建立了一个绑定某个结果到依赖数据的关系。只有当依赖变了，这个结果才需要被重新得到。 useRef：在多次渲染之间共享数据 ini 复制代码const myRefContainer =useRef(initialValue); 我们可以把 useRef 看作是在函数组件之外创建的一个容器空间。在这个容器上，我们可以通过唯一的 current 属设置一个值，从而在函数组件的多次渲染之间共享这个值。 ","date":"2023-11-21","objectID":"/3/:1:7","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"useRef 的重要的功能 1. 存储跨渲染的数据 使用 useRef 保存的数据一般是和 UI 的渲染无关的，因此当 ref 的值发生变化时，是不会触发组件的重新渲染的，这也是 useRef 区别于 useState 的地方。 举例： scss 复制代码 const [time, setTime] = useState(0); // 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量 const timer = useRef(null); const handleStart = useCallback(() =\u003e { // 使用 current 属性设置 ref 的值 timer.current = window.setInterval(() =\u003e { setTime((time) =\u003e time + 1); }, 100); }, []); 2. 保存某个 DOM 节点的引用 是在某些场景中，我们必须要获得真实 DOM 节点的引用，所以结合 React 的 ref 属性和 useRef 这个 Hook，我们就可以获得真实的 DOM 节点，并对这个节点进行操作。 React 官方例子： javascript 复制代码function TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () =\u003e { // current 属性指向了真实的 input 这个 DOM 节点，从而可以调用 focus 方法 inputEl.current.focus(); }; return ( \u003c\u003e \u003cinput ref={inputEl} type=\"text\" /\u003e \u003cbutton onClick={onButtonClick}\u003eFocus the input\u003c/button\u003e \u003c/\u003e ); } 理解： 可以看到ref 这个属性提供了获得 DOM 节点的能力，并利用 useRef 保存了这个节点的应用。这样的话，一旦 input 节点被渲染到界面上，那我们通过 inputEl.current 就能访问到真实的 DOM 节点的实例了 ","date":"2023-11-21","objectID":"/3/:1:8","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"useContext：定义全局状态 ","date":"2023-11-21","objectID":"/3/:1:9","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"为什么要使用 useContext？ React 组件之间的状态传递只有一种方式，那就是通过 props。缺点： 这种传递关系只能在父子组件之间进行。 那么问题出现：跨层次，或者同层的组件之间要如何进行数据的共享？这就涉及到一个新的命题： 全局状态管理 。 react提供的解决方案： Context 机制。 ","date":"2023-11-21","objectID":"/3/:1:10","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"具体原理： React 提供了 Context 这样一个机制， 能够让所有在某个组件开始的组件树上创建一个 Context 。这样这个组件树上的所有组件，就都能访问和修改这个 Context 了。 那么在函数组件里，我们就可以使用 useContext 这样一个 Hook 来管理 Context。 ","date":"2023-11-21","objectID":"/3/:1:11","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"使用：（这儿用了官方例子） javascript 复制代码const themes = { light: { foreground: \"#000000\", background: \"#eeeeee\" }, dark: { foreground: \"#ffffff\", background: \"#222222\" } }; // 创建一个 Theme 的 Context const ThemeContext = React.createContext(themes.light); function App() { // 整个应用使用 ThemeContext.Provider 作为根组件 return ( // 使用 themes.dark 作为当前 Context \u003cThemeContext.Provider value={themes.dark}\u003e \u003cToolbar /\u003e \u003c/ThemeContext.Provider\u003e ); } // 在 Toolbar 组件中使用一个会使用 Theme 的 Button function Toolbar(props) { return ( \u003cdiv\u003e \u003cThemedButton /\u003e \u003c/div\u003e ); } // 在 Theme Button 中使用 useContext 来获取当前的主题 function ThemedButton() { const theme = useContext(ThemeContext); return ( \u003cbutton style={{ background: theme.background, color: theme.foreground }}\u003e I am styled by theme context! \u003c/button\u003e ); } ","date":"2023-11-21","objectID":"/3/:1:12","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"优点： Context 提供了一个方便在多个组件之间共享数据的机制。 ","date":"2023-11-21","objectID":"/3/:1:13","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"缺点： Context 相当于提供了一个定义 React 世界中全局变量的机制，而全局变量则意味着两点： 1. 会让调试变得困难，因为你很难跟踪某个 Context 的变化究竟是如何产生的。 2. 让组件的复用变得困难，因为一个组件如果使用了某个 Context ，它就必须确保被用到的地方一定有这个 Context 的 Provider 在其父组件的路径上。 实际应用场景 由于以上缺点，所以在 React 的开发中，除了像 Theme、Language 等一目了然的需要全局设置的变量外），我们很少会使用 Context 来做太多数据的共享。需要再三强调的是，Context 更多的是提供了一个强大的机制，让 React 应用具备定义全局的响应式数据的能力。 此外，很多状态管理框架，比如 Redux，正是利用了 Context 的机制来提供一种更加可控的组件之间的状态管理机制。因此，理解 Context 的机制，也可以让我们更好地去理解 Redux 这样的框架实现的原理。 ","date":"2023-11-21","objectID":"/3/:1:14","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"最后 其实了解学会了useState 和 useEffect 这两个 核心 Hooks，基本能完成绝大多数 React 功能的开发了。 useCallback、useMemo、useRef 和 useContext。这几个 Hook 都是为了解决函数组件中遇到的特定问题。 ","date":"2023-11-21","objectID":"/3/:1:15","tags":["react","钩子函数"],"title":"React钩子","uri":"/3/"},{"categories":["技术"],"content":"SpringBoot集成flyway 在 pom.xml 加入如下依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.flywaydb\u003c/groupId\u003e \u003cartifactId\u003eflyway-core\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.flywaydb\u003c/groupId\u003e \u003cartifactId\u003eflyway-mysql\u003c/artifactId\u003e \u003c/dependency\u003e 在application.yml中加入配置 flyway: #是否开启flyway，默认true enabled: false #当迁移时发现目标schema非空，而且没有元数据的表时，（即迭代中项目）是否自动执行基准迁移，默认false. baseline-on-migrate: true # 是否允许无序运行迁移, 默认false，建议开发环境开启，生成环境关闭 out-of-order: true #设定SQL脚本的目录,可以配置多个，比如为classpath:db/migration,filesystem:/sql-migrations,默认classpath:db/migration locations: - classpath:db/migration sql文件命名规范 Prefix 前缀：V 代表版本迁移，U 代表撤销迁移，R 代表可重复迁移 Version 版本号：版本号通常 . 和整数组成 Separator 分隔符：固定由两个下划线 __ 组成 Description 描述：由下划线分隔的单词组成，用于描述本次迁移的目的 Suffix 后缀：如果是 SQL 文件那么固定由 .sql 组成，如果是基于 Java 类则默认不需要后缀 例如V1.0__init_db.sql 执行了 V1.0__init_db.sql 脚本后，从而创建了 user 表，另外还自动创建了 flyway_schema_history 表，用于记录所有版本演化和状态，其表结构如下(以 MySQL 为例)： 注意 org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.api.FlywayException: Validate failed: Migration checksum mismatch for migration version 1.0 -\u003e Applied to database : 1317299633 -\u003e Resolved locally : -1582367361 这个错误的原因就是 Flyway 会给脚本计算一个 checksum 保存在数据库中，用于在之后运行过程中对比 sql 文件是否有变化，如果发生了变化，则会报错，也就防止了误修改脚本导致发生问题。 ","date":"2023-11-21","objectID":"/4/:0:1","tags":["SpringBoot","java"],"title":"SpringBoot集成flyway","uri":"/4/"},{"categories":["第一"],"content":" 功能测试文章 Lighthouse (image) images: [] tags: [] categories: [] featuredImage: \"\" featuredImagePreview: \"\" tags: 文章的标签. categories: 文章所属的类别. lightgallery: true $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} This is a tip 一个 技巧 横幅 或者 This is a tip 一个 技巧 横幅 ","date":"2023-11-21","objectID":"/first_post-%E5%89%AF%E6%9C%AC-5-%E5%89%AF%E6%9C%AC/:0:0","tags":["第一","第二"],"title":"测试文章4","uri":"/first_post-%E5%89%AF%E6%9C%AC-5-%E5%89%AF%E6%9C%AC/"},{"categories":["第一"],"content":" 功能测试文章 Lighthouse (image) images: [] tags: [] categories: [] featuredImage: \"\" featuredImagePreview: \"\" tags: 文章的标签. categories: 文章所属的类别. lightgallery: true $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} This is a tip 一个 技巧 横幅 或者 This is a tip 一个 技巧 横幅 ","date":"2023-11-21","objectID":"/first_post-%E5%89%AF%E6%9C%AC-6-%E5%89%AF%E6%9C%AC/:0:0","tags":["第一","第二"],"title":"测试文章4","uri":"/first_post-%E5%89%AF%E6%9C%AC-6-%E5%89%AF%E6%9C%AC/"},{"categories":["第一"],"content":" 功能测试文章 Lighthouse (image) images: [] tags: [] categories: [] featuredImage: \"\" featuredImagePreview: \"\" tags: 文章的标签. categories: 文章所属的类别. lightgallery: true $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} This is a tip 一个 技巧 横幅 或者 This is a tip 一个 技巧 横幅 ","date":"2023-11-21","objectID":"/first_post-%E5%89%AF%E6%9C%AC-7-%E5%89%AF%E6%9C%AC/:0:0","tags":["第一","第二"],"title":"测试文章4","uri":"/first_post-%E5%89%AF%E6%9C%AC-7-%E5%89%AF%E6%9C%AC/"},{"categories":["第一"],"content":" 功能测试文章 Lighthouse (image) images: [] tags: [] categories: [] featuredImage: \"\" featuredImagePreview: \"\" tags: 文章的标签. categories: 文章所属的类别. lightgallery: true $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} This is a tip 一个 技巧 横幅 或者 This is a tip 一个 技巧 横幅 ","date":"2023-11-21","objectID":"/first_post-%E5%89%AF%E6%9C%AC-8-%E5%89%AF%E6%9C%AC/:0:0","tags":["第一","第二"],"title":"测试文章4","uri":"/first_post-%E5%89%AF%E6%9C%AC-8-%E5%89%AF%E6%9C%AC/"},{"categories":["技术"],"content":" 线程同步可以说在日常开发中是用的很多， 但对于其内部如何实现的，一般人可能知道的并不多。介绍linux中的锁实现futex的优点及原理，最后分析java中同步机制如wait/notify, synchronized, ReentrantLock。 ","date":"2023-11-20","objectID":"/2/:0:0","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"自己实现锁 ","date":"2023-11-20","objectID":"/2/:1:0","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"自旋 volatile int status=0; void lock(){ while(!compareAndSet(0,1)){ } //get lock } void unlock(){ status=0; } boolean compareAndSet(int except,int newValue){ //cas操作,修改status成功则返回true } 上面的代码通过自旋和cas来实现一个最简单的锁。 这样实现的锁显然有个致命的缺点：耗费cpu资源。没有竞争到锁的线程会一直占用cpu资源进行cas操作，假如一个线程获得锁后要花费10s处理业务逻辑，那另外一个线程就会白白的花费10s的cpu资源。（假设系统中就只有这两个线程的情况）。 ","date":"2023-11-20","objectID":"/2/:1:1","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"yield+自旋 要解决自旋锁的性能问题必须让竞争锁失败的线程不忙等,而是在获取不到锁的时候能把cpu资源给让出来，说到让cpu资源，你可能想到了yield()方法，看看下面的例子： volatile int status=0; void lock(){ while(!compareAndSet(0,1)){ yield(); } //get lock } void unlock(){ status=0; } 当线程竞争锁失败时，会调用yield方法让出cpu。需要注意的是该方法只是当前让出cpu，有可能操作系统下次还是选择运行该线程。其实现是 将当期线程移动到所在优先调度队列的末端（操作系统线程调度了解一下？有时间的话，下次写写这块内容）。也就是说，如果该线程处于优先级最高的调度队列且该队列只有该线程，那操作系统下次还是运行该线程。 自旋+yield的方式并没有完全解决问题，当系统只有两个线程竞争锁时，yield是有效的。但是如果有100个线程竞争锁，当线程1获得锁后，还有99个线程在反复的自旋+yield，线程2调用yield后，操作系统下次运行的可能是线程3；而线程3CAS失败后调用yield后，操作系统下次运行的可能是线程4… 假如运行在单核cpu下，在竞争锁时最差只有1%的cpu利用率，导致获得锁的线程1一直被中断，执行实际业务代码时间变得更长，从而导致锁释放的时间变的更长。 ","date":"2023-11-20","objectID":"/2/:1:2","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"sleep+自旋 当竞争锁失败后，可以将用Thread.sleep将线程休眠，从而不占用cpu资源： volatile int status=0; void lock(){ while(!compareAndSet(0,1)){ sleep(10); } //get lock } void unlock(){ status=0; } 上述方式我们可能见的比较多，通常用于实现上层锁。该方式不适合用于操作系统级别的锁，因为作为一个底层锁，其sleep时间很难设置。sleep的时间取决于同步代码块的执行时间，sleep时间如果太短了，会导致线程切换频繁（极端情况和yield方式一样）；sleep时间如果设置的过长，会导致线程不能及时获得锁。因此没法设置一个通用的sleep值。就算sleep的值由调用者指定也不能完全解决问题：有的时候调用锁的人也不知道同步块代码会执行多久。 ","date":"2023-11-20","objectID":"/2/:1:3","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"park+自旋 那可不可以在获取不到锁的时候让线程释放cpu资源进行等待，当持有锁的线程释放锁的时候将等待的线程唤起呢？ volatile int status=0; Queue parkQueue; void lock(){ while(!compareAndSet(0,1)){ // lock_wait(); } //get lock } void synchronized unlock(){ lock_notify(); } void lock_wait(){ //将当期线程加入到等待队列 parkQueue.add(nowThread); //将当期线程释放cpu releaseCpu(); } void lock_notify(){ //得到要唤醒的线程 Thread t=parkList.poll(); //唤醒等待线程 wakeAThread(t); } 上面是伪代码，描述这种设计思想，至于释放cpu资源、唤醒等待线程的的具体实现 ","date":"2023-11-20","objectID":"/2/:1:4","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"小结 对于锁冲突不严重的情况，用自旋锁会更适合，试想每个线程获得锁后很短的一段时间内就释放锁，竞争锁的线程只要经历几次自旋运算后就能获得锁，那就没必要等待该线程了，因为等待线程意味着需要进入到内核态进行上下文切换，而上下文切换是有成本的并且还不低，如果锁很快就释放了，那上下文切换的开销将超过自旋。 目前操作系统中，一般是用自旋+等待结合的形式实现锁：在进入锁时先自旋一定次数，如果还没获得锁再进行等待。 ","date":"2023-11-20","objectID":"/2/:1:5","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"futex linux底层用futex实现锁，futex由一个内核层的队列和一个用户空间层的atomic integer构成。当获得锁时，尝试cas更改integer，如果integer原始值是0，则修改成功，该线程获得锁，否则就将当期线程放入到 wait queue中（即操作系统的等待队列）。 上述说法有些抽象，如果你没看明白也没关系。我们先看一下没有futex之前，linux是怎么实现锁的。 ","date":"2023-11-20","objectID":"/2/:2:0","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"futex诞生之前 在futex诞生之前，linux下的同步机制可以归为两类：用户态的同步机制 和内核同步机制。 用户态的同步机制基本上就是利用原子指令实现的自旋锁。关于自旋锁其缺点也说过了，不适用于大的临界区（即锁占用时间比较长的情况）。 内核提供的同步机制，如semaphore等，使用的是上文说的自旋+等待的形式。 它对于大小临界区和都适用。但是因为它是内核层的（释放cpu资源是内核级调用），所以每次lock与unlock都是一次系统调用，即使没有锁冲突，也必须要通过系统调用进入内核之后才能识别。 理想的同步机制应该是没有锁冲突时在用户态利用原子指令就解决问题，而需要挂起等待时再使用内核提供的系统调用进行睡眠与唤醒。换句话说，在用户态的自旋失败时，能不能让进程挂起，由持有锁的线程释放锁时将其唤醒？ 如果你没有较深入地考虑过这个问题，很可能想当然的认为类似于这样就行了（伪代码）： void lock(int lockval) { //trylock是用户级的自旋锁 while(!trylock(lockval)) { wait();//释放cpu，并将当期线程加入等待队列，是系统调用 } } boolean trylock(int lockval){ int i=0; //localval=1代表上锁成功 while(!compareAndSet(lockval,0,1)){ if(++i\u003e10){ return false; } } return true; } void unlock(int lockval) { compareAndSet(lockval,1,0); notify(); } 上述代码的问题是trylock和wait两个调用之间存在一个窗口： 如果一个线程trylock失败，在调用wait时持有锁的线程释放了锁，当前线程还是会调用wait进行等待，但之后就没有人再将该线程唤醒了。 ","date":"2023-11-20","objectID":"/2/:2:1","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"},{"categories":["技术"],"content":"futex诞生之后 我们来看看futex的方法定义： //uaddr指向一个地址，val代表这个地址期待的值，当*uaddr==val时，才会进行wait int futex_wait(int *uaddr, int val); //唤醒n个在uaddr指向的锁变量上挂起等待的进程 int futex_wake(int *uaddr, int n); futex_wait真正将进程挂起之前会检查addr指向的地址的值是否等于val，如果不相等则会立即返回，由用户态继续trylock。否则将当期线程插入到一个队列中去，并挂起。 futex内部维护了一个队列，在线程挂起前会线程插入到其中，同时对于队列中的每个节点都有一个标识，代表该线程关联锁的uaddr。这样，当用户态调用futex_wake时，只需要遍历这个等待队列，把带有相同uaddr的节点所对应的进程唤醒就行了。 作为优化，futex维护的其实是个类似java 中的concurrent hashmap的结构。其持有一个总链表，总链表中每个元素都是一个带有自旋锁的子链表。调用futex_wait挂起的进程，通过其uaddr hash到某一个具体的子链表上去。这样一方面能分散对等待队列的竞争、另一方面减小单个队列的长度，便于futex_wake时的查找。每个链表各自持有一把spinlock，将\"*uaddr和val的比较操作\"与\"把进程加入队列的操作\"保护在一个临界区中。 另外，futex是支持多进程的，当使用futex在多进程间进行同步时，需要考虑同一个物理内存地址在不同进程中的虚拟地址是不同的。 ","date":"2023-11-20","objectID":"/2/:2:2","tags":["多线程","线程安全"],"title":"线程同步...","uri":"/2/"}]